mod authority;
mod event;
mod operation;
mod types;
mod install;
mod util;
use chain_cloud_util::types as ccu;
use ic_cdk::api;
use ic_cdk::export::candid::Nat;
use ic_cdk::export::Principal;
use ic_cdk_macros::*;
use types::*;
#[macro_use]
extern crate lazy_static; 
use std::sync::RwLock;
use event::EventLog;
lazy_static!{
    pub static ref event_log: RwLock<EventLog> = RwLock::new(EventLog::new(150,100000, "4000000000000".parse().unwrap()));
}

#[init]
fn init() {

    authority::set_owner(api::caller());
}

/// Generate a canister transaction event
/// Note that this method stores the collected canisters' running status information in the current canisters in the form of events,
/// and provides developers with canisters' running status, 
/// including the frequency of canisters executing transactions, 
/// the number of canisters' cycles consumed in each transaction, 
/// the remaining cycles of the current canisters and other information, 
/// so as to optimize with developers
#[update(name = "createEvent")]
async fn create_event(new_log: ccu::Log) -> Result<(), String> {
    event::create_event(new_log).await
}

/// Query canisters event
/// @param:canister  canister address
/// @param:offset  Event start location
/// @param:limit  Number of events 
#[query(name = "getCanisterEvent")]
async fn get_canister_event(
    canister: Principal,
    offset: Nat,
    limit: Nat,
) -> Vec<ccu::Log> {
    event::get_canister_event(canister, offset, limit).await
}

/// Note: Query canisters event information of ordinary account calls
/// @parma:caller Account address
/// @param:offset Event start location
/// @param:limit  Number of events 
#[query(name = "getCallerEvent")]
async fn get_caller_event(caller: Principal, offset: Nat, limit: Nat) -> Vec<ccu::Log> {
    event::get_caller_event(caller, offset, limit).await
}

/// Note: Get the latest events generated by other canisters collected by the current canisters
/// @param:limit Number of events
#[query(name = "getLastEvent")]
async fn get_last_event(limit: Nat) -> Vec<ccu::Log> {
    event::get_last_event(limit).await
}

/// Note: Gets the latest event information generated by the specified container
/// @param:canister canister address
/// @param:limit Number of events
#[query(name = "getCanisterLastEvent")]
async fn get_canister_last_event(canister: Principal, limit: Nat) -> Vec<ccu::Log> {
    event::get_canister_last_event(canister, limit).await
}

/// Note: List of all canisters stored in the current container
#[query(name = "getCanisterList")]
async fn get_canister_list() -> Vec<Principal> {
    event::get_canister_list().await
}

/// Note: Get canisterstatus information
/// including canisters, remaining cycles and modules_hash、controller、memory_size、status
/// @param:canister canister address
/// @param:calltype  If the canisterinformation exists in the current container, return the stored information. If it does not exist, call managementCanisters get information and put it back
#[update(name = "getCanisterStatus")]
async fn get_canister_status(
    canister: Principal,
    calltype: CallType,
) -> Result<CanisterStatusFormat, String> {
    operation::get_canister_status(canister, calltype).await
}

#[query(name = "getLocalCanisterList")]
async fn get_local_canister_list() -> Vec<CanisterStatusFormat> {
    operation::get_local_canister_list().await
}

#[update(name = "commitCanister")]
async fn commit_canister(canister: CommitCanister) -> () {
    return operation::commit_canister(canister).await;
}

/// Note: Query the list of all canisters under the account
/// @param:principle principle address
#[query(name = "getCanisterByPrinciple")]
async fn get_canister_by_principle(principle: Principal) -> Vec<CommitCanister> {
    return operation::get_canister_by_principle(principle).await;
}

/// Note: Obtain canisterinformation from the specified identity
/// @param:principle principle address 
/// @param:canister_id canister address
#[query(name = "getCanisterById")]
async fn get_canister_by_id(
    principle: Principal,
    canister_id: Principal,
) -> Result<CommitCanister, String> {
    return operation::get_canister_by_id(principle, canister_id).await;
}

/// Note: Get canisters events based on time
/// @param:canister canister address 
/// @param:start_time  Time when the event occurred
#[query(name = "getCanisterEventByTime")]
async fn get_canister_event_by_time(
    canister: Principal,
    start_time: Nat,
) -> Vec<ccu::Log> {
    return event::get_canister_event_by_time(canister, start_time).await;
}

#[query]
async fn is_canister(id:Principal)->(){
    util::is_canister(id).await;
}
/// Note: Before the upgrade task starts, you need to persist the data in memory
#[pre_upgrade]
fn pre_upgrade() {
   event::pre_upgrade();
}

/// Note: Before the upgrade task ends, you need to reload the persistent data into memory
#[post_upgrade]
fn post_update() {
    event::post_update();
}